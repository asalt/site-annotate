---
title: "site-annotate-notreduced"
author: "MSPC"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: hide
    highlight: zenburn
    toc: yes
    toc_float: false
params:
  data_dir: NULL
  metadata: NULL
---

<style type="text/css">
.main-container {
  max-width: 100% !important;
  margin: auto;
}
</style>


```{r setup, include=T}
knitr::opts_chunk$set(echo = TRUE)
suppressPackageStartupMessages(library(rlang))
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(magrittr))
suppressPackageStartupMessages(library(purrr))
suppressPackageStartupMessages(library(ComplexHeatmap))
suppressPackageStartupMessages(library(circlize))
suppressPackageStartupMessages(library(reactable))
library(knitr)
suppressPackageStartupMessages(library(here))

src_dir <- file.path(here("R"))
io_tools <- new.env()
source(file.path(src_dir, "./io.R"), local = io_tools)

# Define a custom chunk hook
# not quite....
# knit_hooks$set(trycatch = function(before, options) {
#   if (before) {
#     # Before chunk execution, wrap in tryCatch
#     sprintf("tryCatch({\n")
#   } else {
#     # After chunk execution, close tryCatch and handle error
#     sprintf("}, error = function(e) { knitr::knit_exit() })\n")
#   }
# })

# Apply the custom hook to all chunks
# knitr::opts_chunk$set(trycatch = TRUE)

myreactable <- function(x, ...) reactable(x, defaultPageSize = 4, searchable = T, compact = T, ...)
```


# load
```{r}
(data_dir <- params$data_dir)
(metadata <- params$metadata)
data_dir <- "/media/alex/Expansion/MSPC001141/data/processed/phos/fragpipe_current"
metadata <- "/media/alex/Expansion/MSPC001141/data/processed/phos/fragpipe_current/metadata.tsv"

if (is.null(data_dir)) {
  ( data_dir <- Sys.getenv("data_dir", unset = ".") )
  if (is.null(data_dir)) {
    cat("data dir not set")
    knitr::knit_exit()
  }
}

print(data_dir)
```


```{r}
(files <- fs::dir_ls(data_dir , regexp = ".*reduced.tsv$", fail = F, recurse = T))

if (length(files) == 0) {
  cat("no files found")
  knitr::knit_exit()
}


my_set_names <- io_tools$set_name

datas <- files %>%
  purrr::set_names(nm = ~ my_set_name(.)) %>% # set names first
  purrr::map(~ {
    .table <- read_tsv(.x, show_col_types = F)
    return(.table)
  })

file_path_names <- list(files)
names(file_path_names) <- names(datas)

datas %<>% purrr::map(
  ~ {
    .x %>% dplyr::filter(AA %in% c("S", "T", "Y"))
  }
)


extract_key_value_pairs <- io_tools$extract_key_value_pairs
input_string <- "ENSP|ENSMUSP00000001963|ENST|ENSMUST00000001963|ENSG|ENSMUSG00000020681|geneid|11421|taxon|10090|symbol|Ace|Ace"
( key_value_pairs <- extract_key_value_pairs(input_string) )



.all_proteins <- datas %>% purrr::map(~{.x %>% distinct(protein) %>% pull(protein)}) %>% unlist() %>% unique()
.res <- .all_proteins %>% 
  purrr::map(
    extract_key_value_pairs
  ) 
.res <- set_names(.res, .all_proteins)  # Ensure names are set for each element in the list
geneinfo <- .res %>%
  purrr::imap_dfr(~{
    values <- .x
    original_str <- .y
    # Convert each named vector to a tibble (a transposed tibble for named vector handling)
    as_tibble(t(values)) %>%
      dplyr::mutate(protein = original_str)  # Set the protein identifier using the name from the list
  })


geneinfo_counts <- geneinfo %>%
  pivot_longer(-protein) %>% 
  group_by(name) %>% 
  summarize( n = sum(!is.na(value)) )
geneinfo_counts %<>% dplyr::filter( n > 1 )
geneinfo %<>% dplyr::select( protein, all_of(geneinfo_counts$name) )
geneinfo <- geneinfo %>%
  mutate(across(everything(), ~ replace_na(., "")))

  

datas %<>% purrr::map(
  ~{
    .x %>% left_join(geneinfo)
  }
)


```


```{r}
names(datas)
```

```{r}
head(datas[[1]]) %>% 
  dplyr::select(
      # protein,
      ENSP, ENST, ENSG, geneid, taxon, symbol, fifteenmer,
      peptide,
      modified_peptide,
      sty_79_9663
  ) %>% 
  myreactable()
```





# count

```{r}
datas[[1]] %>%
  dplyr::filter(AA %in% c("S", "T", "Y")) %>%
  head(20) %>%
  dplyr::select(fifteenmer, protein, position_absolut, everything()) %>%
  myreactable()
```

## all counts

```{r}
# Group by 'AA' and count occurrences
aa_count <- datas[[1]] %>%
  distinct(fifteenmer, .keep_all = T) %>%
  group_by(AA) %>%
  summarize(sites = n())

aa_count %>% myreactable()
```

## probability above .75

```{r}
# Group by 'AA' and count occurrences
aa_count <- datas[[1]] %>%
  distinct(fifteenmer, .keep_all = T) %>%
  dplyr::filter(prob > .75) %>%
  group_by(AA) %>%
  summarize(sites = n())
```


```{r}
# Display the AA count
aa_count %>% myreactable()

```


# plots

```{r}
datas[[1]] %>% ggplot(aes(x = prob)) +
  geom_histogram(binwidth = 0.01, fill = "#1c3079", color = "black") +
  theme_minimal() +
  labs(title = "Distribution of Prob", x = "Prob", y = "Count")
```


```{r}
datas[[1]] %>% 
  ggplot(aes(x = charge)) +
  geom_bar(fill = "green", color = "black") +
  theme_minimal() +
  labs(title = "Distribution of Charge", x = "Charge", y = "Count")
```



```{r}
datas[[1]] %>% 
  ggplot(aes(x = intensity)) +
  geom_histogram(fill = "#1c3079", color = "grey50",
                 binwidth = function(x) 2 * IQR(x) / (length(x)^(1/3))
) +
  theme_minimal() +
  labs(title = "Distribution of Intensity", x = "Intensity", y = "Count") +
  scale_x_log10() # Log scale for better visualization
```


# reduce to site level

```{r}

# this is the 'non parallel' version:
# datas_reduced <- datas %>% purrr::map(
#   ~{
#     common_cols <- intersect(colnames(geneinfo), colnames(.x))  # Check against the first dataframe or ensure it's generalizable
#     .x %>%
#       head(1000) %>% 
#       #group_by(fifteenmer, all_of(colnames(geneinfo))) %>% 
#       group_by(fifteenmer, !!!rlang::syms(common_cols)) %>%
#       summarise(across(matches("TMT_.*intensity$"), sum, na.rm = TRUE), .groups = "drop")
#       # sum up all the columns that are of form TMT_xxx_x_intensity
#   }
# )


n_workers <- future::availableCores() - 1

future::plan(future::multisession, workers = n_workers)
# from https://stackoverflow.com/a/69008715
datas_reduced <- datas %>% 
  purrr::map(~{
    common_cols <- intersect(colnames(geneinfo), colnames(.x))  # Check against the first dataframe or ensure it's generalizable
    .data_chunks <- .x %>%
      group_nest(fifteenmer, !!!rlang::syms(common_cols), .key = "grouped_data") %>%
      dplyr::mutate(.worker_id = sample(1:n_workers, replace=T, size=nrow(.))) %>% 
      dplyr::group_split(.worker_id, .keep=F) 
    .data_chunks %>% 
      furrr::future_map_dfr(
        function(.data) tidyr::unnest(.data, grouped_data) %>% 
          group_by(fifteenmer, !!!rlang::syms(common_cols)) %>%
          summarise(out = across(matches("TMT_.*intensity$"), .fns = \(x) sum(x, na.rm = TRUE) )) %>% 
          ungroup() %>% 
          unnest(out)
      )
  }
  )

datas_reduced %<>% purrr::map( ~{ 
  .newnames <- colnames(.x) %>% str_remove('_intensity')
  colnames(.x) <- .newnames
  return(.x)
  } )
datas_reduced[[1]] %>% head



```

# export 
```{r, label='do export'}

datas_reduced  %>% purrr::imap(~{
  df <- .x
  name <- .y
  orig_path <- file_path_names[[name]]
  rootdir <- fs::path_dir(orig_path)
  newfile <- fs::path_join(c(rootdir, "site_annotation_reduced.tsv"))
  print(orig_path)
  readr::write_tsv(df, newfile)
})
```


